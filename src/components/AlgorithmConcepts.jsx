import React from 'react';
import { Link } from 'react-router-dom';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { ScrollArea } from '@/components/ui/scroll-area';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';

const AlgorithmConcepts = () => {
  const concepts = [
    {
      id: 'what-is-algorithm',
      title: 'アルゴリズムとは？',
      description: `アルゴリズムとは、特定の問題を解決するための一連の手順や命令の明確な集合です。コンピュータサイエンスにおいて、アルゴリズムは計算可能な問題を解決するための効率的な方法を提供します。料理のレシピや地図の経路案内も一種のアルゴリズムと考えることができます。

## アルゴリズムの特性

1.  **明確性 (Definiteness)**: 各ステップは明確で曖昧さがない。
2.  **有限性 (Finiteness)**: 有限の時間で終了する。
3.  **入力 (Input)**: ゼロ個以上の入力を持つ。
4.  **出力 (Output)**: 少なくとも一つ以上の出力を持つ。
5.  **有効性 (Effectiveness)**: 各ステップは基本的な操作に分解でき、実行可能である。

## アルゴリズムの重要性

アルゴリズムは、ソフトウェア開発、データ分析、人工知能、科学計算など、現代のあらゆる情報技術の基盤となっています。効率的なアルゴリズムは、大規模なデータを高速に処理し、複雑な問題を解決するために不可欠です。`,
      tags: ['basic', 'concept', 'definition']
    },
    {
      id: 'time-complexity',
      title: '時間計算量 (Time Complexity)',
      description: `時間計算量とは、アルゴリズムの実行に要する時間の量を、入力サイズnの関数として表現したものです。通常、最悪ケースのシナリオで、アルゴリズムのステップ数を数えることで評価されます。これにより、異なるアルゴリズムの効率性を比較し、大規模な入力に対してどのアルゴリズムがより適しているかを判断できます。

## 評価方法

時間計算量は、通常、**O記法（Big O Notation）**を用いて表現されます。O記法は、入力サイズが非常に大きくなったときに、アルゴリズムの実行時間がどのように増加するかを示すものです。定数や低次の項は無視され、最も支配的な項のみが考慮されます。

### 一般的なO記法

-   **O(1) - 定数時間**: 入力サイズに関わらず、実行時間が一定。
    例: 配列の特定インデックスへのアクセス。
-   **O(log n) - 対数時間**: 入力サイズが増加するにつれて、実行時間が対数的に増加。
    例: 二分探索。
-   **O(n) - 線形時間**: 入力サイズに比例して実行時間が増加。
    例: 線形探索、配列の走査。
-   **O(n log n) - 線形対数時間**: 効率的なソートアルゴリズムによく見られる。
    例: マージソート、クイックソート（平均）。
-   **O(n²) - 二次時間**: 入力サイズの二乗に比例して実行時間が増加。
    例: バブルソート、挿入ソート、選択ソート。
-   **O(2^n) - 指数時間**: 入力サイズに対して実行時間が指数関数的に増加。非常に非効率。
    例: 総当たり探索（一部の問題）。
-   **O(n!) - 階乗時間**: 入力サイズに対して実行時間が階乗的に増加。極めて非効率。
    例: 巡回セールスマン問題の総当たり探索。

## 時間計算量の計算例

### 線形探索 (O(n))

要素数nの配列から目的の要素を探す場合、最悪ケースではすべての要素を一度ずつ確認する必要があります。したがって、実行時間はnに比例し、O(n)となります。

### バブルソート (O(n²))

要素数nの配列をバブルソートする場合、外側のループがn回、内側のループが最大n回実行されるため、合計で約n*n回の比較・交換操作が発生します。したがって、実行時間はnの二乗に比例し、O(n²)となります。

時間計算量は、アルゴリズムの選択において最も重要な要素の一つであり、特に大規模なデータセットを扱う場合には、その効率性がシステムのパフォーマンスに直接影響します。`,
      tags: ['complexity', 'performance', 'big-o']
    },
    {
      id: 'space-complexity',
      title: '空間計算量 (Space Complexity)',
      description: `空間計算量とは、アルゴリズムの実行に要するメモリ空間の量を、入力サイズnの関数として表現したものです。時間計算量と同様に、O記法を用いて評価されます。アルゴリズムが使用するメモリには、入力データ自体が占める空間と、アルゴリズムが実行中に一時的に使用する補助空間（スタック、キュー、変数など）が含まれます。

## 評価方法

空間計算量もO記法で表現され、主に補助空間の量に注目します。入力データが占める空間は、通常、問題の性質によって決まるため、アルゴリズム自体の効率性を評価する際には補助空間がより重要視されます。

### 一般的なO記法

-   **O(1) - 定数空間**: 入力サイズに関わらず、使用するメモリ空間が一定。
    例: バブルソート、挿入ソート、選択ソート（インプレースソート）。
-   **O(log n) - 対数空間**: 入力サイズが増加するにつれて、使用するメモリ空間が対数的に増加。
    例: クイックソート（再帰スタック）。
-   **O(n) - 線形空間**: 入力サイズに比例して使用するメモリ空間が増加。
    例: マージソート（一時配列）、ハッシュテーブル。
-   **O(n²) - 二次空間**: 入力サイズの二乗に比例して使用するメモリ空間が増加。
    例: 動的計画法の一部（2次元配列を使用する場合）。

## 空間計算量の計算例

### バブルソート (O(1))

バブルソートは、配列内で直接要素を交換するため、追加のメモリをほとんど必要としません。少数の変数（ループカウンタや一時的な交換用変数など）しか使用しないため、空間計算量はO(1)となります。

### マージソート (O(n))

マージソートは、配列を分割し、ソートされた部分配列をマージする際に、一時的な配列を作成します。この一時配列のサイズは、元の配列のサイズに比例するため、空間計算量はO(n)となります。

現代のコンピュータは大量のメモリを搭載していますが、組み込みシステムや大規模なデータ処理においては、空間計算量も重要な考慮事項となります。特に、再帰的なアルゴリズムでは、再帰の深さに応じてスタック空間が消費されるため、注意が必要です。`,
      tags: ['complexity', 'memory', 'big-o']
    }
  ];

  return (
    <ScrollArea className="h-full w-full p-4 md:p-6">
      <div className="max-w-4xl mx-auto">
        <h1 className="text-3xl font-bold mb-6">アルゴリズムの基本概念</h1>
        <div className="grid gap-6">
          {concepts.map((concept) => (
            <Card key={concept.id} className="w-full">
              <CardHeader>
                <CardTitle className="text-2xl">{concept.title}</CardTitle>
                <div className="flex flex-wrap gap-2 mt-2">
                  {concept.tags.map((tag) => (
                    <Badge key={tag} variant="secondary">{tag}</Badge>
                  ))}
                </div>
              </CardHeader>
              <CardContent>
                <ReactMarkdown remarkPlugins={[remarkGfm]}>
                  {concept.description}
                </ReactMarkdown>
              </CardContent>
            </Card>
          ))}
        </div>
      </div>
    </ScrollArea>
  );
};

export default AlgorithmConcepts;


